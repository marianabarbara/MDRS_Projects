% Modelação e Desempenho de Redes e Serviços -> Projeto 2 - Task 1

%% Task 1.a - Shortest Path Routing

% Tráfego Unicast: fluxos entre nós específicos (origem → destino)
% Tráfego Anycast: fluxos onde o destino é o nó anycast mais próximo (nós 5 e 12)

clear;
clc;

% Carregar dados de input
load('InputDataProject2.mat');

% L  -> Matriz de comprimento entre Links (Km)
% Tu -> Unicast flows: [src dst up down] (Gbps)
% Ta -> Anycast flows: [src up down] (Gbps)

nNodes = size(L,1);
C = 50;                 % Capacidade dos Links (Na task 1 e 2 é pedido que seja 50) (Gbps)
anycastNodes = [5 12];  % Nós que permitem tráfego Anycast são segundo o enunciado o 5 e o 12.

% Construir o grafo (Usando os comprimentos dos Links)
Adj = inf(nNodes);
Adj(L > 0) = L(L > 0);
Adj(1:nNodes+1:end) = 0;

G = graph(Adj);

% Inicializar a matriz de carga dos links (Gbps)
linkLoad = zeros(nNodes);

% Tráfego Unicast (Caminho mais curto)
for f = 1:size(Tu,1)

    s = Tu(f,1);
    d = Tu(f,2);
    up = Tu(f,3);
    down = Tu(f,4);

    % s -> d
    pathSD = shortestpath(G, s, d);
    for k = 1:length(pathSD)-1
        i = pathSD(k);
        j = pathSD(k+1);
        % Adicionar ambas as direções para os links sem direção
        linkLoad(min(i,j), max(i,j)) = linkLoad(min(i,j), max(i,j)) + up;
    end

    % d -> s
    pathDS = shortestpath(G, d, s);
    for k = 1:length(pathDS)-1
        i = pathDS(k);
        j = pathDS(k+1);
        % Adicionar ambas as direções para os links sem direção
        linkLoad(min(i,j), max(i,j)) = linkLoad(min(i,j), max(i,j)) + down;
    end
end

% Tráfego Anycast (Caminho mais curto)
for f = 1:size(Ta,1)

    s = Ta(f,1);
    up = Ta(f,2);
    down = Ta(f,3);

    % Caminho mais curto para cada nó Anycast
    [path5, d5]   = shortestpath(G, s, anycastNodes(1));
    [path12, d12] = shortestpath(G, s, anycastNodes(2));

    if d5 <= d12
        acNode = anycastNodes(1);
        pathUp = path5;
    else
        acNode = anycastNodes(2);
        pathUp = path12;
    end

    % s -> anycast (upstream)
    for k = 1:length(pathUp)-1
        i = pathUp(k);
        j = pathUp(k+1);
        % Adicionar ambas as direções para os links sem direção
        linkLoad(min(i,j), max(i,j)) = linkLoad(min(i,j), max(i,j)) + up;
    end

    % anycast -> s (downstream)
    pathDown = shortestpath(G, acNode, s);
    for k = 1:length(pathDown)-1
        i = pathDown(k);
        j = pathDown(k+1);
        % Adicionar ambas as direções para os links sem direção
        linkLoad(min(i,j), max(i,j)) = linkLoad(min(i,j), max(i,j)) + down;
    end
end

% Computar as cargas dos links e a pior carga
linkLoadVec = [];
linkIndex = [];

for i = 1:nNodes
    for j = i+1:nNodes
        if L(i,j) > 0
            linkLoadVec(end+1) = linkLoad(i,j);
            linkIndex(end+1,:) = [i j];
        end
    end
end

[worstLinkLoad, idx] = max(linkLoadVec);
worstUtilization = worstLinkLoad / C * 100;


% Resultados
fprintf('--- Task 1.a Results ---\n');
fprintf('Worst link load: %.2f Gbps\n', worstLinkLoad);
fprintf('Worst link utilization: %.2f %%\n', worstUtilization);
fprintf('Worst link: (%d - %d)\n', linkIndex(idx,1), linkIndex(idx,2));

% Mostrar as cargas de todos os links
disp('Link loads (Gbps):');
for k = 1:length(linkLoadVec)
    fprintf('Link %2d-%2d : %6.2f Gbps\n', ...
        linkIndex(k,1), linkIndex(k,2), linkLoadVec(k));
end


%% Task 1.b - Consumo de Energia da Rede
% É preciso a carga dos Links do exercicio 1.a

% Parâmetros
routerCapacity = 500;  % De acordo com o enunciado (Consider that each router has a capacity of 500 Gbps)
nNodes = size(linkLoad,1); % Número de Nós na rede


% Consumo de Energia do Router
routerLoad = zeros(nNodes,1);

% Somar todo o tráfego que passa por cada Router
for i = 1:nNodes
    routerLoad(i) = sum(linkLoad(i,:));
end

% Computar a Energia do Router
routerEnergy = zeros(nNodes,1);
for i = 1:nNodes
    t = routerLoad(i) / routerCapacity;
    routerEnergy(i) = 10 + 90 * t^2;
end

totalRouterEnergy = sum(routerEnergy);

% Consumo de Energia dos Links
linkEnergy = 0;
sleepingLinks = [];

for i = 1:nNodes
    for j = i+1:nNodes
        if L(i,j) > 0   % Link Existente

            if linkLoad(i,j) > 0
                % Link ativo (50 Gbps)
                El = 6 + 0.2 * L(i,j);
            else
                % Link em modo adormecido
                El = 2;
                sleepingLinks(end+1,:) = [i j];
            end

            linkEnergy = linkEnergy + El;
        end
    end
end

% Energia total da Rede
totalEnergy = totalRouterEnergy + linkEnergy;

% Resultados
fprintf('\n--- Task 1.b Results ---\n');
fprintf('Total router energy: %.2f\n', totalRouterEnergy);
fprintf('Total link energy: %.2f\n', linkEnergy);
fprintf('Total network energy: %.2f\n', totalEnergy);

fprintf('\nSleeping links:\n');
if isempty(sleepingLinks)
    fprintf('None\n');
else
    for k = 1:size(sleepingLinks,1)
        fprintf('Link %d-%d\n', sleepingLinks(k,1), sleepingLinks(k,2));
    end
end





%% Task 1.c - Multi Start Hill Climbing
% Minimizar a carga do pior Link
% Usar o Yen's k-shortest path algorithm que foi fornecido nas aulas.

clear;

% Carregar dados
load('InputDataProject2.mat');

k = 6;              % Número de caminhos candidatos.
timeLimit = 30;     % tempo limite pedido no enunciado em segundos.
nNodes = size(L,1);
nFlows = size(Tu,1);

% Construir a matriz de custo (Comprimento dos links)
netCostMatrix = inf(nNodes);
netCostMatrix(L > 0) = L(L > 0);
netCostMatrix(1:nNodes+1:end) = 0;

% Computar o  k-shortest paths para cada flow unicast
paths = cell(nFlows,1);

for f = 1:nFlows
    s = Tu(f,1);
    d = Tu(f,2);

    [sp, ~] = kShortestPath(netCostMatrix, s, d, k);
    paths{f} = sp;
end

% Multi Start Hill Climbing
bestGlobalCost = inf;
bestGlobalSolution = [];
bestTime = 0;

tStart = tic;

while toc(tStart) < timeLimit

    % Inicial greedy randomized solution
    sol0 = greedyRandomInitialSolution(paths);

    % Hill Climbing optimization
    [sol, cost] = hillClimbing(sol0, paths, Tu, L, nNodes);

    % Update global be
    if cost < bestGlobalCost
        bestGlobalCost = cost;
        bestGlobalSolution = sol;
        bestTime = toc(tStart);
    end
end

% Display results
fprintf('--- Task 1.c Results ---\n');
fprintf('Worst link load: %.2f Gbps\n', bestGlobalCost);
fprintf('Best solution found at %.2f seconds\n', bestTime);



%% =========================
% Task 1.d – Multi Start HC
% =========================

clear;
% clc removed to preserve previous task outputs
load('InputDataProject2.mat');

nNodes = size(L,1);
nFlows = size(Tu,1);
linkCapacity = 50; % Gbps
k = 6;
timeLimit = 30; % seconds

% -------------------------
% Build graph from L
% -------------------------
G = graph(L, 'upper');

% -------------------------
% Compute k-shortest paths
% -------------------------
paths = cell(nFlows,1);

for f = 1:nFlows
    s = Tu(f,1);
    d = Tu(f,2);
    paths{f} = kShortestPath(L, s, d, k);
end

% -------------------------
% Multi Start Hill Climbing
% -------------------------
bestGlobalCost = inf;
bestGlobalSol = [];
bestTime = 0;

tStart = tic;

while toc(tStart) < timeLimit

    % --- Greedy randomized initial solution
    sol0 = greedyRandomInitialSolution(paths);

    % --- Hill climbing improvement
    [sol, cost] = hillClimbing(sol0, paths, Tu, L, nNodes);

    % --- Check if global best
    if cost < bestGlobalCost
        bestGlobalCost = cost;
        bestGlobalSol = sol;
        bestTime = toc(tStart);
    end
end

% -------------------------
% Evaluate final solution
% -------------------------
[linkLoads] = computeLinkLoads(bestGlobalSol, paths, Tu, nNodes);

worstLinkLoad = max(linkLoads(:)) / linkCapacity;

[energy, sleepingLinks] = computeNetworkEnergy(linkLoads, L);

% -------------------------
% Display results
% -------------------------
fprintf('\n===== Task 1.d Results =====\n');
fprintf('Worst link load        : %.4f\n', worstLinkLoad);
fprintf('Network energy (W)     : %.2f\n', energy);
fprintf('Number of sleeping links: %d\n', size(sleepingLinks,1));
fprintf('Best solution found at : %.2f seconds\n', bestTime);
